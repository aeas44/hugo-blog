+++
date = "2016-03-08T16:54:34+09:00"
draft = false
title = "CoreOS 入門"

+++

(この記事は「[An Introduction to CoreOS System Components](https://www.digitalocean.com/community/tutorials/an-introduction-to-coreos-system-components)」の翻訳です)

### CoreOS とは何か?

CoreOS は大規模かつスケーラブルなデプロイを簡単に実現できる Linux ディストリビューションです。Chrome OS から派生した CoreOS は軽量なホスト環境を提供し、アプリケーションは Docker コンテナとして実行します。これにより、プロセスの隔離とクラスタ内でのアプリケーションの移行を簡素化します。

クラスタを管理するため、CoreOS は `etcd` と呼ばれるグローバルな key-value ストレージを使い、ノード間で設定情報を交換します。このコンポーネントのおかげで、共有情報を元にアプリケーションを動的に設定できます。このような機能をサービス・ディスカバリと呼びます。

クラスタ内でアプリケーションを管理したり、スケジューリングをしたりするため、`fleet` というソフトウェアが使われます。`fleet` はクラスタ全体の init システムとして振る舞い、クラスタ内のプロセスを管理します。これにより、高可用性アプリケーションの設定が可能となり、どのノードからでもクラスタをコントロールすることができるようになります。これは個々のノードの systemd init と連携することで実現されます。

この記事では CoreOS のコンセプトを紹介し、それを実現するためのコンポーネントについて説明します。続けて [DigitalOcean での CoreOS のはじめかた](https://www.digitalocean.com/community/tutorials/how-to-set-up-a-coreos-cluster-on-digitalocean) についてもご紹介します (訳注: リンク先は英語です)。

### CoreOS の設計

全般的に CoreOS はクラスタリングとコンテナ運用がしやすいように作られています。

ホスト自身は比較的シンプルで、普通のサーバの「機能」の多くは削られています。CoreOS にはパッケージ管理ソフトウェアすらありません。アプリケーションは Docker コンテナとして起動することが期待されています。このことにより、リソースの隔離やポータビリティ、コンテナ外からのサービスの管理が可能になります。

CoreOS は起動時に、"cloud-config" という設定ファイルを読み込みます。この設定情報はクラスタ内の他のノードと接続したり、基本的なサービスの起動や重要なパラメータを再設定するために使われます。これにより CoreOS は起動と同時にクラスタの一員として働きはじめられます。

通常 "cloud-config" ファイルは、最低でもクラスタへ参加する方法と `etcd` および `fleet` を起動するコマンドを記述します。この3つは互いに関連しています。これらの情報は新しいノードをクラスタ内のノードと接続させ、クラスタ内のノードを設定または管理する手段を提供します。これは CoreOS  ノードがクラスタに参加するために必要です。

`etcd` デーモンはデータをクラスタ内の各ノードに伝播します。クラスタ全体で一貫性のある設定情報を保持することと、どのサービスが他ノードに情報伝達するのかを管理するために有用です。このサービス・ディスカバリ機構は、サービスが自身の設定情報を問い合わせるために使われます。例えば、ロードバランサが背後にいるウェブサーバのIPアドレスを `etcd` に尋ねるケースなどが考えられるでしょう。

`fleet` デーモンは分散 init システムとして機能します。`fleet` はクラスタに存在する各ノードの systemd init にフックし、サービスのスケジューリングや、ユーザ定義にもとづいたデプロイ対象の制限などを行います。ユーザは `fleet` のおかげで、個々のノードの状態をいちいち心配することなく、クラスタを一つのマシンとして捉えることができます。

CoreOS システムの振る舞いについてイメージが湧いたでしょうか。それでは次に各々のコンポーネントについて詳細に見ていきましょう。これらのコンポーネントについて理解することは、とても大切です。

### Docker の概要

Docker は LXC (Linux コンテナ) を利用したコンテナ・システムです。カーネルの名前空間と cgroups を使い、各々のプロセスを隔離します。

このことから、アプリケーションは外部環境の影響を受けずに動作することができます。つまり、ソフトウェアの分散がぐっと簡単になるのです。Docker コンテナはどの環境においても同じように動くので、例えばノートパソコンで開発したコンテナはデータセンタのクラスタでも同様に動きます。

Docker を使い、ソフトウェア自身と実行環境を一緒に配布できます。Docker コンテナは他のコンテナと協調して動作することもできるし、一つのサーバとして動かすこともきます。仮想化技術と比較した場合の Docker のメリットは、OS 全体をエミュレートしないことです。Docker はアプリケーションに必要なコンポーネントのみをエミュレートします。したがって、仮想化と同じようなことが可能でありながら、計算資源をそれほど使わずにすみます。

CoreOS は Docker コンテナを一段と便利なものにします。CoreOS では、ほとんど全てのアプリケーションがコンテナ内で動くのです。ちょっと大変なように思えるかもしれませんが、クラスタ間での協調がぐっと容易になります。CoreOS は基本的にクラスタレベルで動作するように設計されており、単体のサーバとして使われることを想定しているわけではないのです。

CoreOS では、このようにして簡単に分散サービスを運用できます。CoreOS に含まれるツールは、指定した条件を満たす計算資源を持つノードでのプロセス実行を可能にします。Docker は各ノードを個別に設定せずとも、分散システムにおいて協調して動作する自己充足的な単位として振る舞うことが可能です。

### Etcd の概要

一貫性のあるグローバルなデータを各ノード間で共有し、サービスディカバリ機能を実現するために `etcd` は開発されました。

`etcd` サービスは可用性の高い key-value ストアであり、各ノードは設定情報をここから読み込みます。また、稼働中のサービスについての情報を検索したり、よそのノードに知らせるべき情報を書き出すためにも使われます。それぞれのノードは自身の `etcd` クライアントを持ち、他のクライアントとも情報を共有できるように設定されます。

各アプリケーションは、単にローカルの `etcd` インタフェースに接続するだけで情報を取得できます。全ての `etcd` データは、実際にそれがどこで保存されているかに関わらず、どのノードでも取得可能です。データはクラスタ内で自動的に分散され、複製されるためです。リーダー選挙も自動で行われるため、key-value ストアの管理は簡単です。

`etcd` データを扱うには HTTP/JSON API を使うか (デフォルトのエンドポイントは [http://127.0.0.1:4001/v2/keys/](http://127.0.0.1:4001/v2/keys/))、`etcd` に含まれている `etcdctl` というユーティリティを使います。どちらの方法でも簡単にデータを扱うことができます。

HTTP API は Docker コンテナの中からもアクセス可能であることに注意してください。つまり、各コンテナは `etcd` にある値を参照することができるのです。

### Fleet の概要

実際に CoreOS クラスタを作成するには `fleet` というツールが使われます。簡単に言えば、`fleet` はクラスタで機能する init システムです。

クラスタ内の各ノードは伝統的な systemd の init を使います。これは自身のサービスを開始するためのものです。単純化してしまえば、`fleet` はクラスタのメンバーの systemd を管理するインタフェースを提供するのです。

サービスの起動や停止、クラスタ内で動いているプロセスのステータス情報の取得にくわえて、`fleet` はさらに重要な事も行います。`fleet` はプロセスを分散する機構を持ち、より負荷の小さいホストでサービスを実行することもできるのです。

起動するサービスに対して条件を指定することもできます。例えば、サービスを特定のホストでのみ動かすように指定することもできます。ホストがどこに存在するのか、すでに動作しているプロセスは何なのか、などの条件によってです。`fleet` はホストにおけるプロセスの起動に systemd を使うため、サービスを定義するのは systemd の Unit ファイルになります (いくつかのカスタムオプションもあります)。これらの設定ファイルを `fleet` に渡すと、クラスタ内で管理されることになります。

この柔軟性は高可用性を持つシステムを設計するために役立ちます。例えば、ウェブサーバとして振る舞うコンテナを複数のノードにデプロイすることができます。同様に、依存関係のあるコンテナが動いているノードにのみ、コンテナをデプロイすることも可能です。

全てのノードにおいて、クラスタを `fleectl` で管理できます。サービスのスケジューリングや、ノードの管理、システムのステータスを監視できます。`fleetctl` はクラスタに対するインタフェースの役割を果たします。

### まとめ

CoreOS は多くの Linux ディストリビューションとは違います。設計上の意志決定はクラスタの管理のしやすさや、ポータビリティにもとづいて行われています。このような思想から、CoreOS という強力な、モダンでスケーラブルなディストリビューションが生まれました。

さらに CoreOS について興味があれば、[CoreOS クラスタリングに関するガイド](https://www.digitalocean.com/community/tutorials/how-to-set-up-a-coreos-cluster-on-digitalocean)をご覧ください。

### ライセンス

原文は [CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/) で提供されています。本記事も同ライセンスに従います。
